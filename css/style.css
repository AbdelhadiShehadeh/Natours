/* For the best browser optimization we should only animate('in @keyframes') two properities which are: Opacity and Transform. */
@keyframes moveInLeft {
  0% {
    opacity: 0;
    transform: translateX(-10rem); }
  80% {
    transform: translateX(1rem); }
  100% {
    opacity: 1;
    transform: translate(0); } }

@keyframes moveInRight {
  0% {
    opacity: 0;
    transform: translateX(10rem); }
  80% {
    transform: translateX(-1rem); }
  100% {
    opacity: 1;
    transform: translate(0); } }

@keyframes moveInBottom {
  0% {
    opacity: 0;
    transform: translateY(3rem); }
  100% {
    opacity: 1;
    transform: translate(0); } }

*,
*::before,
*::after {
  padding: 0px;
  margin: 0px;
  box-sizing: inherit;
  /*The box-sizing property is not inherted by default so we need to implicitly define it to inhert so all our elements will have the box-sizing set to border-box(defined later in the html decalration) */ }

html {
  font-size: 62.5%;
  /*Can use 0.625rem instead of percentage here in both cases it will be relative to the browser default declaration */ }

body {
  box-sizing: border-box;
  /* so if we add margin it won't be added to the total width or height*/ }

body {
  font-family: "Lato", sans-serif;
  font-weight: 400;
  /* Boldness of a color */
  line-height: 1.7;
  color: #777;
  /* This is inhereted through all the children's */
  padding: 3rem; }

.heading-primary {
  color: #fff;
  text-transform: uppercase;
  /*
  -webkit-backface-visibility: hidden;
  backface-visibility: hidden;
  This properity is used when we need to hide the backface ('backside') of the animated element if the animation will show it.
  example is when we rotate an element. Using "Can I use" website it says that the backward visibility properity is not supported in Safari so we need to use the -webkit- option.
  */
  margin-bottom: 6rem; }
  .heading-primary--main {
    display: block;
    /* We made the two span elements to be block so each on will take its own 100% of the width of that block */
    font-size: 6rem;
    font-weight: 400;
    letter-spacing: 3.5rem;
    animation: moveInLeft 1s ease-out;
    /* It's just shortend CSS properity
        animation-name: moveInLeft;
        animation-duration: 1s;
        animation-timing-function: ease-out;
    */
    /* another important animation properities 
        animation-delay: 1s;
        animation-iteration-count: 3;
    */ }
  .heading-primary--sub {
    display: block;
    font-size: 2rem;
    font-weight: 700;
    letter-spacing: 1.75rem;
    animation: moveInRight 1s ease-out; }

.heading-secondary {
  font-size: 3.5rem;
  font-weight: 700;
  text-transform: uppercase;
  background-image: linear-gradient(to right, #7ed56f, #28b485);
  -webkit-background-clip: text;
  -moz-background-clip: text;
  background-clip: text;
  color: transparent;
  letter-spacing: 0.2rem;
  transition: all 0.2s; }
  .heading-secondary:hover {
    transform: skewY(2deg) skewX(15deg) scale(1.1);
    text-shadow: 0.5rem 1rem 2rem rgba(0, 0, 0, 0.2); }

.heading-tertiary {
  font-size: 1.6rem;
  font-weight: 700;
  text-transform: uppercase; }

.paragraph {
  font-size: 1.6rem; }
  .paragraph:not(:last-child) {
    margin-bottom: 3rem; }

.u-center-text {
  text-align: center; }

.u-margin-bottom-big {
  margin-bottom: 8rem; }

.u-margin-bottom-medium {
  margin-bottom: 4rem; }

.u-margin-bottom-small {
  margin-bottom: 1.5rem; }

.btn:link, .btn:hover {
  font-size: 1.6rem;
  position: relative;
  /*We specify the position to be relative for the ::after pseduo element to not be relative to the .text-box element and to be of the .btn itself instead */
  text-transform: uppercase;
  text-decoration: none;
  display: inline-block;
  /*By default its an inline element so we need to change it to inline-block so we can apply padding and margin to the element. */
  padding: 1.5rem 4rem;
  border-radius: 10rem;
  transition: all 0.2s; }

.btn::after {
  /*The ::after pseduo element add a virtual element right behind the element that its targeting and its treated as its child*/
  /*These properities are just needed to specify the ::after pseduo element based on its parent('Targeted element') in our case .btn */
  content: "";
  /* ::after always needs a content properity even if we leaves it empty */
  /*These preporites are to match its parent element */
  display: inline-block;
  height: 100%;
  width: 100%;
  border-radius: 10rem;
  position: absolute;
  top: 0;
  left: 0;
  z-index: -1;
  transition: all 0.4s; }

.btn--animated {
  animation: moveInBottom 0.5s ease-out 0.75s;
  animation-fill-mode: backwards;
  /*animation-fill-mode properity specifies how the animation will be executed. */
  /*animation-fill-mode: backwards means that the 0% animation will be applied to the element before the whole animation executes */ }

.btn:hover {
  transform: translateY(-0.3rem);
  box-shadow: 0rem 2rem 1rem rgba(0, 0, 0, 0.2);
  /*box-shadow: x-axies y-axies blur color(with opacity if needed) */ }
  .btn:hover::after {
    transform: scaleX(1.4) scaleY(1.6);
    opacity: 0;
    /* We used opacity 0 for the ::after element to fade out and in */ }

.btn:active {
  transform: translateY(-0.1rem);
  /* This translate will happen in relation to the main btn position and not the hovered position. */
  box-shadow: 0rem 1rem 0.5rem rgba(0, 0, 0, 0.2); }

.btn--white {
  background-color: #fff;
  color: #777; }
  .btn--white::after {
    background-color: #fff; }

.btn-text:link,
.btn-text:visited {
  display: inline-block;
  font-size: 1.6rem;
  color: #55c57a;
  text-decoration: none;
  border-bottom: 1px solid #55c57a;
  padding: 0.3rem;
  transition: all 0.3s; }
  .btn-text:link:hover,
  .btn-text:visited:hover {
    background-color: #55c57a;
    color: #fff;
    transform: translateY(-2px);
    box-shadow: 0 1rem 2rem rgba(0, 0, 0, 0.15); }
  .btn-text:link:active,
  .btn-text:visited:active {
    box-shadow: 0 0.5rem 1rem rgba(0, 0, 0, 0.15);
    transform: translateY(0); }

.composition {
  position: relative; }
  .composition__photo {
    position: absolute;
    width: 55%;
    border-radius: 0.2rem;
    box-shadow: 0 1.5rem 4rem rgba(0, 0, 0, 0.4);
    z-index: 0;
    transition: all 0.2s;
    outline-offset: 2rem; }
    .composition__photo--p1 {
      left: 0;
      top: -2rem; }
    .composition__photo--p2 {
      right: 0;
      top: 2rem; }
    .composition__photo--p3 {
      left: 20%;
      top: 10rem; }
    .composition__photo:hover {
      outline: 1.5rem solid #55c57a;
      transform: scale(1.05) translateY(-0.5rem);
      box-shadow: 0 2.5rem 4rem rgba(0, 0, 0, 0.5);
      z-index: 1; }
  .composition:hover .composition__photo:not(:hover) {
    transform: scale(0.95); }

.header {
  position: relative;
  height: 95vh;
  background-image: linear-gradient(to bottom right, rgba(126, 213, 111, 0.8), rgba(40, 180, 133, 0.8)), url("../img/hero.jpg");
  background-size: cover;
  background-position: top;
  clip-path: polygon(0 0, 100% 0, 100% 75vh, 0 100%);
  /* This works that all other points are relative to the first point in (x , y) co-ordinates */
  /* We used viewport height (75vh) to keep our website responsive!!! */ }
  .header__logo {
    /*The wdith will be automatically adjusted according to our set height and it works the other way around */
    height: 3.5rem; }
  .header__logo-box {
    position: absolute;
    /* The position of the element is absolute and should be absloute to its parent element and we do that by assigning the position attribute in the parent element to relative. In this case the parent element is the header */
    top: 4rem;
    left: 4rem; }
  .header__text-box {
    position: absolute;
    top: 40%;
    left: 50%;
    transform: translate(-50%, -50%);
    text-align: center;
    /* Since our button is an inline-block it will be treated as a text so "text-align" property will align the button to the center of the text-box element */ }

.row {
  max-width: 114rem;
  margin: 0 auto; }
  .row::after {
    content: "";
    display: table;
    clear: both; }
  .row [class^="col-"] {
    /*
    ^ == class that start with
    * == class that contains 
    $ == class that end with
    */
    float: left; }
    .row [class^="col-"]:not(:last-child) {
      margin-right: 6rem; }
  .row:not(:last-child) {
    margin-bottom: 8rem; }
  .row .col-1-of-2 {
    width: calc((100% - 6rem) / 2); }
  .row .col-1-of-3 {
    width: calc((100% - (2 * 6rem)) / 3); }
  .row .col-2-of-3 {
    width: calc( 2 * ((100% - (2 * 6rem)) / 3) + 6rem); }
  .row .col-1-of-4 {
    width: calc((100% - (3 * 6rem)) / 4); }
  .row .col-2-of-4 {
    width: calc( 2 * ((100% - (3 * 6rem)) / 4) + 6rem); }
  .row .col-3-of-4 {
    width: calc( 3 * ((100% - (3 * 6rem)) / 4) + 2 * 6rem); }

.section-about {
  background-color: #f7f7f7;
  padding: 25rem;
  margin-top: -20vh; }
